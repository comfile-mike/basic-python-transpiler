"use strict";

const path = require("path");

function transpileBasToPython(text, filePath) {
  const lines = text.split(/\r?\n/);
  const basename = path.basename(filePath);
  const output = [
    `# Auto-generated from ${basename}`,
    "# DO NOT EDIT: generated by CUBLOC BASIC transpiler",
    "",
    "import time",
    "from machine import Pin",
    "",
    "_pins_out = {}",
    "_pins_in = {}",
    "",
    "def _gpio_out(port, value=None):",
    "    port = int(port)",
    "    pin = _pins_out.get(port)",
    "    if pin is None:",
    "        pin = Pin(port, Pin.OUT)",
    "        _pins_out[port] = pin",
    "    if value is not None:",
    "        pin.value(1 if value else 0)",
    "",
    "def _gpio_in(port):",
    "    port = int(port)",
    "    pin = _pins_in.get(port)",
    "    if pin is None:",
    "        pin = Pin(port, Pin.IN)",
    "        _pins_in[port] = pin",
    "    return pin.value()",
    "",
    "def create_array(dimensions, value):",
    "    result = value",
    "    for size in reversed(dimensions):",
    "        result = [result for _ in range(int(size))]",
    "    return result",
    "",
  ];

  let indent = 0;
  const doStack = [];

  for (const line of lines) {
    const result = transpileStatement(line, indent, doStack);
    indent = result.indent;
    if (result.lines.length === 0) {
      continue;
    }
    output.push(...result.lines);
  }

  return output.join("\n");
}

function transpileStatement(line, indent, doStack) {
  const withoutLineNumber = line.replace(/^\s*\d+\s*/, "");
  const trimmed = withoutLineNumber.trim();
  const lines = [];

  if (!trimmed) {
    lines.push("");
    return { lines, indent };
  }

  if (/^REM\b/i.test(trimmed)) {
    lines.push(`${indentText(indent)}# ${trimmed.replace(/^REM\b\s*/i, "")}`);
    return { lines, indent };
  }

  if (/^'/.test(trimmed)) {
    lines.push(`${indentText(indent)}# ${trimmed.slice(1).trim()}`);
    return { lines, indent };
  }

  if (/^DO\b/i.test(trimmed)) {
    const condition = parseDoLoopCondition(trimmed.replace(/^DO\b/i, "").trim());
    if (condition && condition.kind === "WHILE" && condition.expr) {
      lines.push(`${indentText(indent)}while ${condition.expr}:`);
      doStack.push({ startCondition: "WHILE" });
    } else if (condition && condition.kind === "UNTIL" && condition.expr) {
      lines.push(`${indentText(indent)}while not (${condition.expr}):`);
      doStack.push({ startCondition: "UNTIL" });
    } else {
      lines.push(`${indentText(indent)}while True:`);
      doStack.push({ startCondition: null });
    }
    return { lines, indent: indent + 1 };
  }

  if (/^LOOP\b/i.test(trimmed)) {
    const condition = parseDoLoopCondition(
      trimmed.replace(/^LOOP\b/i, "").trim()
    );
    const lastDo = doStack.length > 0 ? doStack[doStack.length - 1] : null;

    if (condition && condition.expr && (!lastDo || !lastDo.startCondition)) {
      if (condition.kind === "WHILE") {
        lines.push(`${indentText(indent)}if not (${condition.expr}):`);
        lines.push(`${indentText(indent + 1)}break`);
      } else if (condition.kind === "UNTIL") {
        lines.push(`${indentText(indent)}if (${condition.expr}):`);
        lines.push(`${indentText(indent + 1)}break`);
      }
    }

    if (doStack.length > 0) {
      doStack.pop();
    }

    return { lines, indent: Math.max(0, indent - 1) };
  }

  lines.push(`${indentText(indent)}${transpileSimpleStatement(trimmed)}`);
  return { lines, indent };
}

function transpileSimpleStatement(trimmed) {
  if (/^PRINT\b/i.test(trimmed)) {
    const expr = replaceInCalls(trimmed.replace(/^PRINT\b\s*/i, ""));
    if (!expr) {
      return 'print(end="")';
    }
    return `print(${expr}, end="")`;
  }

  if (/^DEBUG\b/i.test(trimmed)) {
    const expr = replaceInCalls(trimmed.replace(/^DEBUG\b\s*/i, ""));
    return transpileDebug(expr);
  }

  if (/^DELAY\b/i.test(trimmed)) {
    const expr = replaceInCalls(trimmed.replace(/^DELAY\b\s*/i, ""));
    if (!expr) {
      return "time.sleep_ms(0)";
    }
    return `time.sleep_ms(${expr})`;
  }

  if (/^OUTPUT\b/i.test(trimmed)) {
    const expr = replaceInCalls(trimmed.replace(/^OUTPUT\b\s*/i, ""));
    if (!expr) {
      return "_gpio_out()";
    }
    return `_gpio_out(${expr.trim()})`;
  }

  if (/^DIM\b/i.test(trimmed)) {
    const dimLine = trimmed.replace(/^DIM\b\s*/i, "");
    return transpileDim(dimLine);
  }

  if (/^INPUT\b/i.test(trimmed)) {
    const expr = replaceInCalls(trimmed.replace(/^INPUT\b\s*/i, ""));
    if (!expr) {
      return "_gpio_in()";
    }
    if (expr.includes(",") || expr.includes('"')) {
      const parts = expr.split(",");
      if (parts.length === 1) {
        return `${parts[0].trim()} = input()`;
      }
      const prompt = parts.slice(0, -1).join(",").trim();
      const target = parts[parts.length - 1].trim();
      return `${target} = input(${prompt})`;
    }
    return `_gpio_in(${expr.trim()})`;
  }

  if (/^OUT\b/i.test(trimmed)) {
    const expr = replaceInCalls(trimmed.replace(/^OUT\b\s*/i, ""));
    if (!expr) {
      return "_gpio_out()";
    }
    const commaIndex = expr.indexOf(",");
    if (commaIndex === -1) {
      return `_gpio_out(${expr.trim()})`;
    }
    const port = expr.slice(0, commaIndex).trim();
    const value = expr.slice(commaIndex + 1).trim();
    return `_gpio_out(${port}, ${value})`;
  }

  if (/^LET\b/i.test(trimmed)) {
    return replaceInCalls(trimmed.replace(/^LET\b\s*/i, ""));
  }

  if (/^[A-Za-z_][A-Za-z0-9_]*\s*=/.test(trimmed)) {
    return replaceInCalls(trimmed);
  }

  return `# ${replaceInCalls(trimmed)}`;
}

function transpileDim(dimLine) {
  if (!dimLine) {
    return "# DIM";
  }

  if (hasTopLevelComma(dimLine)) {
    return `# DIM ${dimLine}  # MULTI-DECLARATIONS NOT SUPPORTED`;
  }

  let cursor = 0;
  const name = parseIdentifier(dimLine, cursor);
  if (!name) {
    return `# DIM ${dimLine}`;
  }

  cursor = name.end;
  cursor = skipWhitespace(dimLine, cursor);

  let arrayDims = null;
  if (dimLine[cursor] === "(") {
    const closeParen = findMatchingParen(dimLine, cursor);
    if (closeParen === -1) {
      return `# DIM ${dimLine}  # MISSING )`;
    }
    arrayDims = dimLine.slice(cursor + 1, closeParen);
    cursor = closeParen + 1;
  }

  cursor = skipWhitespace(dimLine, cursor);
  const asMatch = /^AS\b/i.exec(dimLine.slice(cursor));
  if (!asMatch) {
    return `# DIM ${dimLine}  # MISSING AS`;
  }

  cursor += asMatch[0].length;
  cursor = skipWhitespace(dimLine, cursor);
  const typeToken = parseIdentifier(dimLine, cursor);
  if (!typeToken) {
    return `# DIM ${dimLine}  # MISSING TYPE`;
  }

  const typeName = typeToken.name.toUpperCase();
  const defaultValue = defaultValueForType(typeName);
  cursor = typeToken.end;
  cursor = skipWhitespace(dimLine, cursor);

  let lengthComment = "";
  if (dimLine[cursor] === "*") {
    cursor = skipWhitespace(dimLine, cursor + 1);
    const lenToken = parseIdentifier(dimLine, cursor);
    if (lenToken) {
      lengthComment = `  # STRING LENGTH ${dimLine.slice(
        lenToken.start,
        lenToken.end
      )}`;
    }
  }

  if (!arrayDims) {
    return `${name.name} = ${defaultValue}${lengthComment}`;
  }

  const dims = arrayDims
    .split(",")
    .map((part) => part.trim())
    .filter(Boolean);

  if (dims.length === 0) {
    return `# DIM ${dimLine}  # EMPTY DIMENSIONS`;
  }

  const dimExprs = dims.map((dim) => adjustDimension(dim));
  return `${name.name} = create_array([${dimExprs.join(", ")}], ${defaultValue})${lengthComment}`;
}

function transpileDebug(expr) {
  if (!expr) {
    return 'print(end="")';
  }

  const parts = splitTopLevelArgs(expr);
  const pythonParts = [];

  for (const rawPart of parts) {
    const part = rawPart.trim();
    if (!part) {
      continue;
    }

    const control = parseDebugControl(part);
    if (control) {
      pythonParts.push(control);
      continue;
    }

    const formatted = parseDebugFormat(part);
    if (formatted) {
      pythonParts.push(formatted);
      continue;
    }

    pythonParts.push(part);
  }

  if (pythonParts.length === 0) {
    return "print()";
  }

  return `print(${pythonParts.join(", ")}, sep="", end="")`;
}

function parseDebugControl(part) {
  const upper = part.toUpperCase();
  if (upper === "CR") {
    return '"\\r\\n"';
  }
  if (upper === "LF") {
    return '"\\n"';
  }
  return null;
}

function parseDebugFormat(part) {
  const match = /^(DEC|HEX)(\d+)?(\?)?\s+(.+)$/i.exec(part);
  if (!match) {
    return null;
  }

  const formatType = match[1].toUpperCase();
  const width = match[2];
  const showName = Boolean(match[3]);
  const expr = match[4].trim();
  const nameMatch = /^[A-Za-z_][A-Za-z0-9_]*$/.exec(expr);
  const name = nameMatch ? nameMatch[0] : null;

  let formattedExpr;
  if (formatType === "HEX") {
    const widthSpec = width ? `0${width}X` : "X";
    formattedExpr = `format(${expr}, "${widthSpec}")`;
  } else {
    if (width) {
      formattedExpr = `format(${expr}, "0${width}d")`;
    } else {
      formattedExpr = `str(${expr})`;
    }
  }

  if (showName && name) {
    return `f"${name}={${formattedExpr}}"`;
  }

  return formattedExpr;
}

function defaultValueForType(typeName) {
  switch (typeName) {
    case "BYTE":
    case "INTEGER":
    case "LONG":
    case "SINGLE":
      return "0";
    case "STRING":
      return '""';
    default:
      return "None";
  }
}

function adjustDimension(dimText) {
  if (/^\d+$/.test(dimText)) {
    return String(Number.parseInt(dimText, 10) + 1);
  }
  return `(${dimText}) + 1`;
}

function hasTopLevelComma(text) {
  let depth = 0;
  let inString = false;
  for (let i = 0; i < text.length; i += 1) {
    const ch = text[i];
    if (inString) {
      if (ch === '"') {
        if (text[i + 1] === '"') {
          i += 1;
        } else {
          inString = false;
        }
      }
      continue;
    }
    if (ch === '"') {
      inString = true;
      continue;
    }
    if (ch === "(") {
      depth += 1;
      continue;
    }
    if (ch === ")") {
      depth = Math.max(0, depth - 1);
      continue;
    }
    if (ch === "," && depth === 0) {
      return true;
    }
  }
  return false;
}

function splitTopLevelArgs(text) {
  const parts = [];
  let current = "";
  let depth = 0;
  let inString = false;

  for (let i = 0; i < text.length; i += 1) {
    const ch = text[i];
    if (inString) {
      current += ch;
      if (ch === '"') {
        if (text[i + 1] === '"') {
          current += text[i + 1];
          i += 1;
        } else {
          inString = false;
        }
      }
      continue;
    }

    if (ch === '"') {
      inString = true;
      current += ch;
      continue;
    }

    if (ch === "(") {
      depth += 1;
      current += ch;
      continue;
    }

    if (ch === ")") {
      depth = Math.max(0, depth - 1);
      current += ch;
      continue;
    }

    if (ch === "," && depth === 0) {
      parts.push(current);
      current = "";
      continue;
    }

    current += ch;
  }

  if (current) {
    parts.push(current);
  }

  return parts;
}

function parseIdentifier(text, startIndex) {
  const match = /^[A-Za-z_][A-Za-z0-9_]*/.exec(text.slice(startIndex));
  if (!match) {
    return null;
  }
  return {
    name: match[0],
    start: startIndex,
    end: startIndex + match[0].length,
  };
}

function skipWhitespace(text, index) {
  let cursor = index;
  while (cursor < text.length && /\s/.test(text[cursor])) {
    cursor += 1;
  }
  return cursor;
}

function replaceInCalls(text) {
  let result = "";
  let inString = false;
  let i = 0;

  while (i < text.length) {
    const ch = text[i];

    if (inString) {
      result += ch;
      if (ch === '"') {
        if (text[i + 1] === '"') {
          result += text[i + 1];
          i += 1;
        } else {
          inString = false;
        }
      }
      i += 1;
      continue;
    }

    if (ch === '"') {
      inString = true;
      result += ch;
      i += 1;
      continue;
    }

    if (ch === "'") {
      result += text.slice(i);
      break;
    }

    if (
      (ch === "I" || ch === "i") &&
      (text[i + 1] === "N" || text[i + 1] === "n") &&
      (i === 0 || !/[A-Za-z0-9_]/.test(text[i - 1]))
    ) {
      let j = i + 2;
      while (j < text.length && /\s/.test(text[j])) {
        j += 1;
      }
      if (text[j] === "(") {
        result += "_gpio_in";
        i += 2;
        continue;
      }
    }

    result += ch;
    i += 1;
  }

  return result;
}

function parseDoLoopCondition(text) {
  if (!text) {
    return null;
  }
  const match = /^(WHILE|UNTIL)\b/i.exec(text);
  if (!match) {
    return null;
  }
  const expr = text.slice(match[0].length).trim();
  return { kind: match[1].toUpperCase(), expr };
}

function indentText(level) {
  return " ".repeat(level * 4);
}

function findMatchingParen(text, openIndex) {
  let depth = 0;
  let inString = false;

  for (let i = openIndex + 1; i < text.length; i += 1) {
    const ch = text[i];
    if (inString) {
      if (ch === '"') {
        if (text[i + 1] === '"') {
          i += 1;
        } else {
          inString = false;
        }
      }
      continue;
    }
    if (ch === '"') {
      inString = true;
      continue;
    }
    if (ch === "(") {
      depth += 1;
      continue;
    }
    if (ch === ")") {
      if (depth === 0) {
        return i;
      }
      depth -= 1;
    }
  }
  return -1;
}

module.exports = {
  transpileBasToPython,
};
